using System.Text;
using CodeChops.ImplementationDiscovery.SourceGeneration.Models;

namespace CodeChops.ImplementationDiscovery.SourceGeneration.SourceBuilders;

internal static class ImplementationIdSourceBuilder
{
    public static void CreateSource(SourceProductionContext context, List<DiscoveredEnum> discoveredEnums, AnalyzerConfigOptionsProvider configOptionsProvider)
    {
        if (discoveredEnums.Count == 0) return;
        
        try
        {
            foreach (var discoveredEnum in discoveredEnums)
                CreateDiscoveredImplementationIdFiles(context, discoveredEnum, configOptionsProvider);
        }
        
#pragma warning disable CS0168
        catch (Exception e)
#pragma warning restore CS0168
        {
            var descriptor = new DiagnosticDescriptor(nameof(ImplementationIdSourceBuilder), "Error", $"{nameof(ImplementationIdSourceBuilder)} failed to generate due to an error. Please inform CodeChops (www.CodeChops.nl). Error: {e}", "Compilation", DiagnosticSeverity.Error, isEnabledByDefault: true);
            context.ReportDiagnostic(Diagnostic.Create(descriptor, null));

            context.AddSource($"{nameof(ImplementationIdSourceBuilder)}_Exception_{Guid.NewGuid()}", SourceText.From($"/*{e}*/", Encoding.UTF8));
        }
    }
    
    private static void CreateDiscoveredImplementationIdFiles(SourceProductionContext context, DiscoveredEnum discoveredEnum, AnalyzerConfigOptionsProvider configOptionsProvider)
    {
        var definition = discoveredEnum.Definition;
        if (!definition.GenerateImplementationIds && !definition.HasSingletonImplementations) return;
        if (definition.HasSingletonImplementations && !definition.GenerateImplementationIds) return;
        
        var partialMembers = discoveredEnum.Members.Where(m => m.IsPartial);
		
        foreach (var member in partialMembers)
        {
            var code = new StringBuilder();

            // Create the whole source.
            code.Append($@"// <auto-generated />
#nullable enable
#pragma warning disable CS0109

{GetUsings()}

{(member.Namespace is null ? null : $"namespace {member.Namespace};")}
");

            var implementationsEnum = definition.ExternalDefinition is null
                ? $"global::{definition.Namespace}.{definition.Name}{definition.TypeParameters}"
                : $"global::{definition.ExternalDefinition.Namespace}.{definition.ExternalDefinition.Name}{definition.ExternalDefinition.TypeParameters}";

            code.AppendLine($@"
{member.Declaration} {member.GetClassName()}{definition.TypeParameters} : IHasImplementationId<{implementationsEnum}>, IHasStaticImplementationId<{implementationsEnum}>
    {definition.BaseTypeGenericConstraints}
{{
");

            if (definition.HasSingletonImplementations)
            {
                code.AppendLine($@"
	public IId Id => ImplementationId;
");
            }
            
            code.AppendLine($@"
	public new static {implementationsEnum} ImplementationId {{ get; }} = {definition.Name}{definition.TypeParameters}.{member.GetSimpleName(definition)};
    public new {implementationsEnum} GetImplementationId() => ImplementationId;
");

            code.AppendLine($@"
}}
       
#nullable restore
");
			
            var implementationIdFileName = FileNameHelpers.GetFileName($"{member.Namespace}.{member.GetSimpleName(definition)}.ImplementationId", configOptionsProvider);
            context.AddSource(implementationIdFileName, SourceText.From(code.ToString(), Encoding.UTF8));

            
            string GetUsings()
            {
                var usings = definition.Usings.Concat(new[] { "using System;", "using CodeChops.ImplementationDiscovery;" });
			
                return usings.Distinct().OrderBy(u => u).Aggregate(new StringBuilder(), (sb, u) => sb.AppendLine(u)).ToString();
            }
        }
    }

}